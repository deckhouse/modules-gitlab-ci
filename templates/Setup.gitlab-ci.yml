# variables:
#   $MODULES_MODULE_SOURCE - base URL for the registry, e.g., registry.example.com/deckhouse/modules
#   $MODULES_MODULE_NAME (Optional) - module name, by default it is equal to the project name
#   $WERF_REPO - registry path, default ${MODULES_MODULE_SOURCE}/${MODULES_MODULE_NAME}
#   $DEV_MODULES_REGISTRY - dev registry path
#   $DEV_MODULES_REGISTRY_LOGIN - login to dev registry
#   $DEV_MODULES_REGISTRY_PASSWORD - password to dev registry
#   $SOURCE_REPO - Source repository address for the module
#   $SOURCE_REPO_SSH_KEY - SSH private key for the source repository
#   $DEV_MODULES_REGISTRY_PASSWORD - password to dev registry
#   $DEV_MODULES_REGISTRY_PASSWORD - password to dev registry
#   $DEV_MODULES_REGISTRY_PASSWORD - password to dev registry
#   $DEV_MODULES_REGISTRY_PASSWORD - password to dev registry
#   SVACE_ANALYZE_HOST - hostname of the svace analyze vm
#   SVACE_ANALYZE_SSH_USER: - ssh user to connect with to svace analyze vm
#   SVACE_ANALYZE_SSH_PRIVATE_KEY - svace analyze server ssh private key
#   DECKHOUSE_LIB_HELM_VERSION - version of deckhouse lib-helm that will be downloaded
#
#   Variables for sign (must be configured in GitLab CI/CD Variables):
#   WERF_ELF_PGP_PRIVATE_KEY_FINGERPRINT - GPG key fingerprint
#   WERF_ELF_PGP_PRIVATE_KEY_PASSPHRASE - GPG key passphrase
#   VAULT_ADDR - URL to Vault address
#   WERF_SIGN_CERT - certificate for signing images
#   WERF_SIGN_INTERMEDIATES - intermediate certificates
#   VAULT_ROLE_ID - ID role for access to Vault
#   VAULT_SECRET_ID - secret ID for access to Vault
#   WERF_SIGN_KEY - private key for signing
#
#   Variables configured in ci file:
#   WERF_BSIGN_ELF_FILES=1 - enable binary signing
#   WERF_SIGN_MANIFEST: "true" - enable image signing
#   WERF_ANNOTATE_LAYERS_WITH_DM_VERITY_ROOT_HASH = true - add dm-verity hashes to layers

#   The GPG key is located locally on the Gitlab runner

variables:
  MODULES_MODULE_NAME: "${CI_PROJECT_NAME}"
  MODULES_MODULE_TAG: ${CI_COMMIT_REF_NAME}
  BASE_IMAGES_VERSION: v0.5.7
  WERF_REPO: ${MODULES_MODULE_SOURCE}/${MODULES_MODULE_NAME}
  WERF_VERSION: "v2.47.5+dk"
  WERF_SIGN_MANIFEST: "true"
  WERF_BSIGN_ELF_FILES: "1"
  WERF_ANNOTATE_LAYERS_WITH_DM_VERITY_ROOT_HASH: "true"

before_script:
  # Setup trdl
  - |
    trdl_version=$(curl -s https://tuf.trdl.dev/targets/channels/0/stable)
    curl -sSLO "https://tuf.trdl.dev/targets/releases/$trdl_version/linux-amd64/bin/trdl"
    install -D trdl ~/bin/trdl
    rm trdl
    export PATH=$PATH:~/bin

  # Setup werf
  - |
    echo "ðŸ”§ Downloading werf binary with signing support from internal repository..."
    curl --fail -sSL -o ~/bin/werf "https://fox.flant.com/api/v4/projects/4052/packages/generic/werf/${WERF_VERSION}/werf" --user "gitlab-ci-token:${CI_JOB_TOKEN}"
    chmod +x ~/bin/werf
    export PATH=~/bin:$PATH
    
    # Check werf version
    werf version
    
    # Setup CI environment for werf
    source $(werf ci-env gitlab --as-file)

    # Login to gitlab registry by default
    if [[ "x${MODULES_REGISTRY_LOGIN}" == "x" ]]; then
      MODULES_REGISTRY_LOGIN="${CI_REGISTRY_USER}"
    fi
    if [[ "x${MODULES_REGISTRY_PASSWORD}" == "x" ]]; then
      MODULES_REGISTRY_PASSWORD="${CI_REGISTRY_PASSWORD}"
    fi
    werf cr login -u ${MODULES_REGISTRY_LOGIN} -p ${MODULES_REGISTRY_PASSWORD} ${MODULES_REGISTRY}

    if [[ -n "${DEV_MODULES_REGISTRY_LOGIN}" && -n "${DEV_MODULES_REGISTRY_PASSWORD}" && -n "${DEV_MODULES_REGISTRY}" ]]; then
      werf cr login -u ${DEV_MODULES_REGISTRY_LOGIN} -p ${DEV_MODULES_REGISTRY_PASSWORD} ${DEV_MODULES_REGISTRY}
    fi

  - |
    echo "ðŸ” Checking required signing variables..."
    
    # Variables that must be set in secrets CI/CD
    REQUIRED_SIGNING_VARS=(
      "WERF_SIGN_CERT"
      "WERF_SIGN_INTERMEDIATES"
      "WERF_SIGN_KEY" 
      "VAULT_ADDR"
      "VAULT_ROLE_ID"
      "VAULT_SECRET_ID"
      "WERF_ELF_PGP_PRIVATE_KEY_FINGERPRINT"
      "WERF_ELF_PGP_PRIVATE_KEY_PASSPHRASE"
    )
    
    # Check secret variables
    for var in "${REQUIRED_SIGNING_VARS[@]}"; do
      if [[ -z "${!var}" ]]; then
        echo "âŒ ERROR: Required secret variable $var is not set!"
        echo "Please configure this variable in GitLab CI/CD settings -> Variables"
        exit 1
      else
        echo "âœ… Secret variable $var is configured"
      fi
    done

  # Setup dmt
  - |
    trdl add dmt https://trrr.flant.dev/trdl-dmt/ 3 e77d785600a8c8612b84b93a5a2e4c48188d68f7478356d0708213e928bf67b024ed412e702dc32930da5c5bfc9b1c44be3ee7a292f923327815c91c6c3c3833
    source $(trdl use dmt 0 stable)

  # Download base images yaml file
  - env | grep BASE_IMAGES_VERSION
  - curl --fail -sSLO https://fox.flant.com/api/v4/projects/deckhouse%2Fbase-images/packages/generic/base_images/${BASE_IMAGES_VERSION}/base_images.yml

  # Download deckhouse lib-helm archive
  - |
    if [[ -n "${DECKHOUSE_LIB_HELM_VERSION}"  ]]; then
      mkdir charts
      curl --fail -sSLO https://github.com/deckhouse/lib-helm/releases/download/deckhouse_lib_helm-${DECKHOUSE_LIB_HELM_VERSION}/deckhouse_lib_helm-${DECKHOUSE_LIB_HELM_VERSION}.tgz --output-dir ./charts
    fi

  # Add ssh keys
  - |
    if [[ -n "${SOURCE_REPO_SSH_KEY}" || -n "${SVACE_ANALYZE_SSH_PRIVATE_KEY}" ]]; then

      eval $(ssh-agent)
      trap "kill -3 ${SSH_AGENT_PID}" ERR EXIT HUP INT QUIT TERM
      export SSH_KNOWN_HOSTS=~/.ssh/known_hosts
      mkdir -p ~/.ssh
      touch ~/.ssh/known_hosts

      if [[ -n "${SOURCE_REPO_SSH_KEY}" ]]; then
        ssh-add - <<< "${SOURCE_REPO_SSH_KEY}"
        if [[ -n "${SOURCE_REPO}" ]]; then
          HOST=$(grep -oP '(?<=@)[^/:]+' <<< ${SOURCE_REPO})
          HOST_KEYS=$(ssh-keyscan -H "$HOST" 2>/dev/null)
          while IFS= read -r KEY_LINE; do
            CONSTANT_PART=$(awk '{print $2, $3}' <<< "$KEY_LINE")
            if ! grep -q "$CONSTANT_PART" ~/.ssh/known_hosts; then
              echo "$KEY_LINE" >> ~/.ssh/known_hosts
            fi
          done <<< "$HOST_KEYS"
        fi
      fi

      if [[ -n "${SVACE_ANALYZE_SSH_PRIVATE_KEY}" ]]; then
        ssh-add - <<< "${SVACE_ANALYZE_SSH_PRIVATE_KEY}"
        if [[ -n "${SVACE_ANALYZE_HOST}" ]]; then
          echo "Adding svace ssh key (ignoring errors)."
          set +e
          HOST=${SVACE_ANALYZE_HOST}
          HOST_KEYS=$(ssh-keyscan -H "$HOST" 2>/dev/null)
          while IFS= read -r KEY_LINE; do
            CONSTANT_PART=$(awk '{print $2, $3}' <<< "$KEY_LINE")
            if ! grep -q "$CONSTANT_PART" ~/.ssh/known_hosts; then
              echo "$KEY_LINE" >> ~/.ssh/known_hosts
            fi
          done <<< "$HOST_KEYS"
          set -e
        fi
      fi
    fi

stages:
  - build
  - deploy
