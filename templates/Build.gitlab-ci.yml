inputs:
  module_source:
    description: 'Registry repository address for of the module, e.g., registry.example.com/module-source'
    type: string
  module_name:
    description: 'Name of the module, e.g., my-module'
    type: string
  module_tag:
    description: 'The version of the module to deploy to release channel, e.g., v1.21.1'
    type: string
  secondary_repo:
    description: 'Secondary repository address for module, e.g., registry.example.com/module-source/module_name'
    type: string
    default: ""
  source_repo:
    description: "Source repository address for the module"
    type: string
    default: ""
  source_repo_ssh_key:
    description: "SSH private key for the source repository"
    type: string
    default: ""
  svace_analyze_host:
    description: 'fqdn address to the svace analyze vm'
    type: string
    default: ""
  svace_analyze_ssh_user:
    description: 'ssh user to connect with to svace analyze vm'
    type: string
    default: ""
  svace_analyze_ssh_key:
    description: "SSH private key for the svace analyze server"
    type: string
    default: ""
  svace_enabled:
    description: "Enable Svace analysis"
    value: "false"
    options:
      - "true"
      - "false"

.lint:
  stage: build
  script:
    - |
      dmt lint ./
  rules:
    - if: $CI_COMMIT_BRANCH
    - if: $CI_COMMIT_TAG
  allow_failure: true

build:
  stage: build
  variables:
    MODULE_SOURCE: $[[ inputs.module_source ]]
    MODULE_NAME: $[[ inputs.module_name ]]
    MODULE_TAG: $[[ inputs.module_tag ]]
    SECONDARY_REPO: $[[ inputs.secondary_repo ]]
    SOURCE_REPO: $[[ inputs.source_repo ]]
    SOURCE_REPO_SSH_KEY: $[[ inputs.source_repo_ssh_key ]]
    SVACE_ANALYZE_HOST: $[[ inputs.svace_analyze_host ]]
    SVACE_ANALYZE_SSH_USER: $[[ inputs.svace_analyze_ssh_user ]]
    SVACE_ANALYZE_SSH_KEY: $[[ inputs.svace_analyze_ssh_key ]]
    SVACE_ENABLED: $[[ inputs.svace_enabled ]]
  before_script:
    - |
      if [[ "${SOURCE_REPO_SSH_KEY}"  != '' || "${SOURCE_REPO_SSH_KEY}" != '' ]]
      if [[ -n "${SSH_AUTH_SOCK}" && -n "${SSH_AGENT_PID}" ]]; then
          echo "Existed ssh agent pid: ${SSH_AGENT_PID}"
          echo "Existed ssh auth sock: ${SSH_AUTH_SOCK}"
          echo "INIT_SSH_AGENT_PID=${SSH_AGENT_PID}" >> $GITHUB_OUTPUT
          echo "INIT_SSH_AUTH_SOCK=${SSH_AUTH_SOCK}" >> $GITHUB_OUTPUT
          eval "$(ssh-agent -s)" > /dev/null
      else
          eval "$(ssh-agent -s)" > /dev/null
      fi
      mkdir -p ~/.ssh
      touch ~/.ssh/known_hosts
      echo "New ssh agent pid: ${SSH_AGENT_PID}"
      echo "New ssh auth sock: ${SSH_AUTH_SOCK}"
      echo "SSH_AGENT_PID=${SSH_AGENT_PID}" >> $GITHUB_ENV
      echo "SSH_AUTH_SOCK=${SSH_AUTH_SOCK}" >> $GITHUB_ENV

    # Add to known_hosts
    - |
      [[ -z "${SOURCE_REPO}" ]] && exit 0
      HOST=$(grep -oP '(?<=@)[^/:]+' <<< ${SOURCE_REPO})
      HOST_KEYS=$(ssh-keyscan -H "$HOST" 2>/dev/null)
      while IFS= read -r KEY_LINE; do
        CONSTANT_PART=$(awk '{print $2, $3}' <<< "$KEY_LINE")
        if ! grep -q "$CONSTANT_PART" ~/.ssh/known_hosts; then
          echo "$KEY_LINE" >> ~/.ssh/known_hosts
        fi
      done <<< "$HOST_KEYS"

      [[ -z "${SVACE_ANALYZE_HOST}" ]] && exit 0
      echo "Adding svace ssh key (ignoring errors)."
      set +e
      HOST=${SVACE_ANALYZE_HOST}
      HOST_KEYS=$(ssh-keyscan -H "$HOST" 2>/dev/null)
      while IFS= read -r KEY_LINE; do
        CONSTANT_PART=$(awk '{print $2, $3}' <<< "$KEY_LINE")
        if ! grep -q "$CONSTANT_PART" ~/.ssh/known_hosts; then
          echo "$KEY_LINE" >> ~/.ssh/known_hosts
        fi
      done <<< "$HOST_KEYS"
      set -e
  script:
    # Build images
    - |
      if [[ -z "${DEV_MODULES_REGISTRY_LOGIN}" && -z "${DEV_MODULES_REGISTRY_PASSWORD}" && -z "${DEV_MODULES_REGISTRY}" ]]; then
        werf build \
          --save-build-report --build-report-path images_tags_werf.json
      else
        werf build \
          --repo=${MODULES_MODULE_SOURCE}/${MODULES_MODULE_NAME} \
          --save-build-report --build-report-path images_tags_werf.json
      fi
      werf build \
        --save-build-report --build-report-path images_tags_werf.json
    # Bundle image
    - |
      IMAGE_SRC="$(jq -r '.Images."bundle".DockerImageName' images_tags_werf.json)"
      IMAGE_DST="$(jq -r '.Images.bundle.DockerRepo' images_tags_werf.json):${MODULES_MODULE_TAG}"

      echo "✨ Pushing ${IMAGE_SRC} to ${IMAGE_DST}"
      crane copy ${IMAGE_SRC} ${IMAGE_DST}
    # Release-channel image
    - |
      IMAGE_SRC="$(jq -r '.Images."release-channel-version".DockerImageName' images_tags_werf.json)"
      IMAGE_DST="$(jq -r '.Images."release-channel-version".DockerRepo' images_tags_werf.json)/release:${MODULES_MODULE_TAG}"

      echo "✨ Pushing ${IMAGE_SRC} to ${IMAGE_DST}"
      crane copy ${IMAGE_SRC} ${IMAGE_DST}
    # Register module
    - |
      echo "✨ Register the module ${MODULES_MODULE_NAME}"
      crane append \
        --oci-empty-base \
        --new_layer "" \
        --new_tag "${MODULES_MODULE_SOURCE}:${MODULES_MODULE_NAME}"
  rules:
    - if: $CI_COMMIT_BRANCH
    - if: $CI_COMMIT_TAG

.svace_rules_mr:
  rules:
    - if: '$CI_MERGE_REQUEST_LABELS =~ /(^|,)analyze\/svace(,|$)/'
      variables:
        SVACE_ENABLED: "true"
.svace_rules_manual:
  rules:
    - if: $CI_PIPELINE_SOURCE == "web" && $SVACE_ENABLED == "true" && $CI_COMMIT_BRANCH
      variables:
        SVACE_ENABLED: "true"
.svace_rules_schedule:
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule" && $SVACE_ENABLED == "true" && $CI_COMMIT_BRANCH
      variables:
        SVACE_ENABLED: "true"