variables:
  GITLEAKS_VERSION: "v8.28.0"
  GITLEAKS_BASE_CONFIG_URL: "https://raw.githubusercontent.com/deckhouse/modules-gitlab-ci/refs/heads/main/gitleaks/config/gitleaks.base.toml"

.gitleaks_scan:
  stage: gitleaks
  variables:
    GIT_DEPTH: 0
  before_script: []
  script:
    - |
      set -euo pipefail
      
      # ========== Install Gitleaks ==========
      echo "üì• Installing Gitleaks $GITLEAKS_VERSION..."
      file_ver="${GITLEAKS_VERSION#v}"
      arch="$(uname -m)"
      case "$arch" in
        x86_64|amd64)  pkg_arch="linux_x64" ;;
        aarch64|arm64) pkg_arch="linux_arm64" ;;
        *) echo "Unsupported arch: $arch"; exit 1 ;;
      esac
      
      base="https://github.com/gitleaks/gitleaks/releases/download/${GITLEAKS_VERSION}"
      tgz="gitleaks_${file_ver}_${pkg_arch}.tar.gz"
      curl -sSL "$base/$tgz" -o gitleaks.tgz
      tar -xzf gitleaks.tgz gitleaks
      chmod +x gitleaks
      mkdir -p "$HOME/.local/bin"
      mv gitleaks "$HOME/.local/bin/"
      export PATH="$HOME/.local/bin:$PATH"
      gitleaks version
      
      # ========== Setup centralized config ==========
      # Download centralized config to temporary directory (safe for Werf/giterminism)
      TMP_BASE_CONFIG="/tmp/gitleaks.base.toml"
      CONFIG_URL="${GITLEAKS_BASE_CONFIG_URL}"
      
      echo "üì• Downloading centralized config..."
      if curl -sSLf "$CONFIG_URL" -o "$TMP_BASE_CONFIG"; then
        echo "‚úÖ Centralized config downloaded to $TMP_BASE_CONFIG"
      else
        echo "‚ö†Ô∏è  Warning: Failed to download centralized config from $CONFIG_URL"
        echo "    Falling back to default Gitleaks rules"
        TMP_BASE_CONFIG=""  # Empty to skip using base config
      fi
      
      # ========== Check for optional local config ==========
      if [[ -f ".gitleaks.toml" ]]; then
        # Local config exists - it should extend the centralized one
        CONFIG_ARG="-c .gitleaks.toml"
        echo "‚úÖ Found local config: .gitleaks.toml (should extend base config)"
      elif [[ -n "$TMP_BASE_CONFIG" && -f "$TMP_BASE_CONFIG" ]]; then
        # Use centralized config only
        CONFIG_ARG="-c $TMP_BASE_CONFIG"
        echo "üîπ Using centralized config only (no local customization)"
      else
        # No config available - use default Gitleaks rules
        CONFIG_ARG=""
        echo "‚ö†Ô∏è No config available. Using default Gitleaks rules."
      fi
      
      # ========== Run scan ==========
      GITLEAKS_EXIT=0
      if [[ "$SCAN_MODE" == "diff" ]]; then
        echo "üïµÔ∏è Running in DIFF mode..."
        
        BASE_COMMIT=$(git merge-base "origin/$CI_MERGE_REQUEST_TARGET_BRANCH_NAME" "$CI_COMMIT_SHA")
        HEAD_COMMIT="$CI_COMMIT_SHA"
        
        echo "‚ñ∂ Target branch: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME"
        echo "‚ñ∂ Base commit (merge-base): $BASE_COMMIT"
        echo "‚ñ∂ Head commit: $HEAD_COMMIT"
        echo "‚ñ∂ Scanning range: ${BASE_COMMIT}..${HEAD_COMMIT}"
        
        gitleaks detect --no-banner --report-format json --report-path gitleaks.json $CONFIG_ARG --source . --log-opts "${BASE_COMMIT}..${HEAD_COMMIT}" || GITLEAKS_EXIT=$?
      elif [[ "$SCAN_MODE" == "full" ]]; then
        echo "üïµÔ∏è Running in FULL mode..."
        gitleaks detect --no-banner --report-format json --report-path gitleaks.json $CONFIG_ARG --source . || GITLEAKS_EXIT=$?
      else
        echo "‚ùå Unknown SCAN_MODE: $SCAN_MODE"
        exit 1
      fi
      
      echo "üîç Gitleaks exit code: $GITLEAKS_EXIT"
      
      # ========== Parse and print results ==========
      echo "üì§ Parsing gitleaks.json for CI log output..."
      echo "DEBUG: Checking gitleaks.json file..."
      ls -lh gitleaks.json || echo "‚ö†Ô∏è gitleaks.json not found!"
      
      if [[ -s gitleaks.json ]]; then
        COUNT=$(jq length gitleaks.json)
        echo "‚ùå Leaks found: $COUNT"
        echo ""
        echo "DEBUG: Attempting to parse and display leaks..."
        
        jq -r '
          def norm:
            {
              file: (.File // .file // .Target // .Location.File // "unknown"),
              line: (.StartLine // .Line // .Location.StartLine // 0),
              rule: (.RuleID // .Rule // .Description // "unknown"),
              commit: (.Commit // .commit // "")
            };
          (if type=="object" and has("findings") then .findings
           elif type=="array" then .
           else [] end)[] | norm
          | "‚Ä¢ [\(.rule)] \(.file):\(.line) \(.commit[0:7] // "no-commit") '$CI_PROJECT_URL'/blob/\(.commit)/\(.file)#L\(.line)"
        ' gitleaks.json | head -n 200
        
        echo ""
        echo "DEBUG: Finished displaying leaks"
        
        # Fail the job if leaks were found
        if [[ "$COUNT" -gt 0 ]]; then
          echo ""
          echo "‚ùå Pipeline failed due to $COUNT leak(s). Review gitleaks.json artifact."
          exit 1
        fi
      else
        echo "‚úÖ No leaks found."
      fi

  after_script:
    - echo "üßπ Cleaning up runner workspace..."
    - rm -f "$HOME/.local/bin/gitleaks" gitleaks.tgz /tmp/gitleaks.base.toml || true

  artifacts:
    when: always
    paths:
      - gitleaks.json

  allow_failure: false

gitleaks_diff:
  extends: .gitleaks_scan
  variables:
    SCAN_MODE: "diff"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

gitleaks_full_manual:
  extends: .gitleaks_scan
  variables:
    SCAN_MODE: "full"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "web"'

gitleaks_full_scheduled:
  extends: .gitleaks_scan
  variables:
    SCAN_MODE: "full"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'

