stages:
  - gitleaks
  - gitleaks_cleanup

variables:
  GITLEAKS_VERSION: "v8.28.0"

.gitleaks_scan:
  stage: gitleaks
  before_script: []
  script:
    - set -euo pipefail

    # Determine arch
    - |
      echo "üì• Installing Gitleaks $GITLEAKS_VERSION..."
      file_ver="${GITLEAKS_VERSION#v}"
      arch="$(uname -m)"
      case "$arch" in
        x86_64|amd64)  pkg_arch="linux_x64" ;;
        aarch64|arm64) pkg_arch="linux_arm64" ;;
        *) echo "Unsupported arch: $arch"; exit 1 ;;
      esac

    # Download and install
    - |
      base="https://github.com/gitleaks/gitleaks/releases/download/${GITLEAKS_VERSION}"
      tgz="gitleaks_${file_ver}_${pkg_arch}.tar.gz"
      curl -sSL "$base/$tgz" -o gitleaks.tgz
      tar -xzf gitleaks.tgz gitleaks
      chmod +x gitleaks
      mkdir -p "$HOME/.local/bin"
      mv gitleaks "$HOME/.local/bin/"
      export PATH="$HOME/.local/bin:$PATH"
      gitleaks version

    # Check for config
    - |
      if [[ -f "gitleaks.toml" ]]; then
        CONFIG_ARG="-c gitleaks.toml"
        echo "‚úÖ Found config: gitleaks.toml"
      else
        CONFIG_ARG=""
        echo "‚ö†Ô∏è Config file not found. Proceeding with default rules."
      fi

    # Run scan
    - |
      if [[ "$SCAN_MODE" == "diff" ]]; then
        echo "üïµÔ∏è Running in DIFF mode..."
        git fetch origin "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME" --depth=0
        BASE_SHA=$(git merge-base origin/$CI_MERGE_REQUEST_TARGET_BRANCH_NAME HEAD || echo "")
        if [[ -z "$BASE_SHA" ]]; then
          echo "‚ùå BASE_SHA not found. Aborting."
          exit 1
        fi
        echo "‚ñ∂ Scanning diff: $BASE_SHA...HEAD"
        gitleaks detect --no-banner --report-format json --report-path gitleaks.json $CONFIG_ARG --source . --log-opts "$BASE_SHA...HEAD"

      elif [[ "$SCAN_MODE" == "full" ]]; then
        echo "üïµÔ∏è Running in FULL mode..."
        gitleaks detect --no-banner --report-format json --report-path gitleaks.json $CONFIG_ARG --source .
      else
        echo "‚ùå Unknown SCAN_MODE: $SCAN_MODE"
        exit 1
      fi

    # Parse and print results
    - |
      echo "üì§ Parsing gitleaks.json for CI log output..."
      if [[ -s gitleaks.json ]]; then
        COUNT=$(jq length gitleaks.json)
        echo "‚ùå Leaks found: $COUNT"
        echo ""
        echo "| Rule | Location | Commit | Link |"
        echo "|------|----------|--------|------|"
        jq -r '
          def norm:
            {
              file: (.File // .file // .Target // .Location.File // ""),
              line: (.StartLine // .Line // .Location.StartLine // 0),
              rule: (.RuleID // .Rule // .Description // ""),
              commit: (.Commit // .commit // "")
            };
          (if type=="object" and has("findings") then .findings
           elif type=="array" then .
           else [] end)[] | norm
          | "| \(.rule) | \(.file):\(.line) | \(.commit[0:7]) | https://'$CI_PROJECT_PATH'/blob/\(.commit)/\(.file)#L\(.line) |"
        ' gitleaks.json | head -n 200
      else
        echo "‚úÖ No leaks found."
      fi


  artifacts:
    when: always
    paths:
      - gitleaks.json

  allow_failure: false

gitleaks_diff:
  extends: .gitleaks_scan
  variables:
    SCAN_MODE: "diff"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

gitleaks_full_manual:
  extends: .gitleaks_scan
  variables:
    SCAN_MODE: "full"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "web"'

gitleaks_full_scheduled:
  extends: .gitleaks_scan
  variables:
    SCAN_MODE: "full"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'

gitleaks_cleanup:
  stage: gitleaks_cleanup
  script:
    - echo "üßπ Cleaning up runner workspace..."
    - rm -f "$HOME/.local/bin/gitleaks" gitleaks.tgz gitleaks.json || true
  needs:
    - job: gitleaks_diff
      artifacts: true
      optional: true
    - job: gitleaks_full_manual
      artifacts: true
      optional: true
    - job: gitleaks_full_scheduled
      artifacts: true
      optional: true
  rules:
    - if: '$CI_JOB_STATUS == "success" || $CI_JOB_STATUS == "failed"'