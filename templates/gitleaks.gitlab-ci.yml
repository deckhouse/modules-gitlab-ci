stages:
  - gitleaks

.gitleaks_scan:
  tags:
    - tfprod-distributed-werf
  stage: gitleaks
  before_script:
    - set -euo pipefail
    - |
      # Ensure basic tools (curl/wget, tar, jq) are available in both shell and container executors
      if ! command -v curl >/dev/null 2>&1 && ! command -v wget >/dev/null 2>&1; then
        if [ -f /etc/alpine-release ]; then
          apk add --no-cache curl || true
        elif [ -f /etc/debian_version ]; then
          apt-get update -y && apt-get install -y curl || true
        fi
      fi
      if ! command -v jq >/dev/null 2>&1; then
        if [ -f /etc/alpine-release ]; then
          apk add --no-cache jq || true
        elif [ -f /etc/debian_version ]; then
          apt-get update -y && apt-get install -y jq || true
        fi
      fi
      if ! command -v tar >/dev/null 2>&1; then
        if [ -f /etc/alpine-release ]; then
          apk add --no-cache tar || true
        elif [ -f /etc/debian_version ]; then
          apt-get update -y && apt-get install -y tar || true
        fi
      fi
    - |
      echo "ðŸ“¥ Installing Gitleaks..."
      ver="v8.28.0"
      file_ver="${ver#v}"
      arch="$(uname -m)"
      case "$arch" in
        x86_64|amd64)  pkg_arch="linux_x64" ;;
        aarch64|arm64) pkg_arch="linux_arm64" ;;
        *) echo "Unsupported arch: $arch"; exit 1 ;;
      esac
      base="https://github.com/gitleaks/gitleaks/releases/download/${ver}"
      tgz="gitleaks_${file_ver}_${pkg_arch}.tar.gz"
      if command -v curl >/dev/null 2>&1; then
        curl -sSL "$base/$tgz" -o gitleaks.tgz
      else
        wget -qO gitleaks.tgz "$base/$tgz"
      fi
      tar -xzf gitleaks.tgz gitleaks
      chmod +x gitleaks
      # Try to put into PATH (works on shell runners); fallback to current dir
      mv -f gitleaks /usr/local/bin/gitleaks 2>/dev/null || mv -f gitleaks ./gitleaks
      if ! command -v gitleaks >/dev/null 2>&1; then
        export PATH="$PWD:$PATH"
      fi
      gitleaks version
  script:
    - |
      if [ ! -f "gitleaks.toml" ]; then
        echo "âŒ Missing config 'gitleaks.toml'"
        exit 1
      fi

      echo "ðŸ•µï¸ Running Gitleaks in mode: $SCAN_MODE"

      if [ "$SCAN_MODE" = "diff" ]; then
        BASE_SHA=$(git merge-base origin/$CI_MERGE_REQUEST_TARGET_BRANCH_NAME HEAD || echo "")
        if [ -z "$BASE_SHA" ]; then
          echo "âš ï¸ Base SHA not found, falling back to full scan"
          SCAN_MODE="full"
        else
          echo "â–¶ Running diff scan $BASE_SHA...HEAD"
          gitleaks detect --no-banner \
            --report-format json --report-path gitleaks.json \
            -c gitleaks.toml --source . --log-opts "$BASE_SHA...HEAD"
        fi
      fi

      if [ "$SCAN_MODE" = "full" ]; then
        echo "â–¶ Running full scan"
        gitleaks detect --no-banner \
          --report-format json --report-path gitleaks.json \
          -c gitleaks.toml --source .
      fi

      echo "ðŸ“„ Report Summary"
      if [ -f gitleaks.json ]; then
        COUNT=$(jq 'if type=="array" then length else 0 end' gitleaks.json)
        echo "Findings: $COUNT"
      else
        echo "No report found"
      fi
  artifacts:
    when: always
    paths:
      - gitleaks.json
    expire_in: 1 week
  after_script:
    - |
      # Cleanup temporary files; keep gitleaks.json for artifact collection
      rm -f /usr/local/bin/gitleaks 2>/dev/null || true
      rm -f ./gitleaks 2>/dev/null || true
      rm -f gitleaks.tgz 2>/dev/null || true
  allow_failure: true

gitleaks_diff:
  extends: .gitleaks_scan
  tags:
    - tfprod-distributed-werf
  variables:
    SCAN_MODE: "diff"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

gitleaks_full:
  extends: .gitleaks_scan
  tags:
    - tfprod-distributed-werf
  variables:
    SCAN_MODE: "full"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "web"'